<?php
/**
 * @file
 *  Ajax facets implementation.
 */

require_once __DIR__ . '/includes/ajax_facets.block.inc';

/**
 * Implements hook_menu().
 */
function ajax_facets_menu() {
  $items = array();

  $items['ajax/ajax_facets/refresh'] = array(
    'title' => 'Callback to update facets content',
    'page callback' => 'ajax_facets_refresh_facets_content',
    'access arguments' => array('access content'),
    'delivery callback' => 'ajax_deliver',
    'type' => MENU_CALLBACK,
    'file' => 'ajax_facets.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ajax_facets_theme() {
  return array(
    'ajax_facets_ranges_input' => array(
      'variables' => array('title' => NULL, 'attributes' => array(), 'value' => NULL),
      'file' => 'ajax_facets.theme.inc',
    ),
  );
}

/**
 * Implements hook_facetapi_widgets().
 */
function ajax_facets_facetapi_widgets() {
  return array(
    // Custom widget to handle ajax-refreshed facets.
    'facetapi_ajax_checkboxes' => array(
      'handler' => array(
        'label' => 'Ajax multiple checkboxes',
        'class' => 'FacetapiAjaxWidgetCheckboxes',
        'query types' => array('term'),
      ),
    ),
    'facetapi_ajax_select' => array(
      'handler' => array(
        'label' => 'Ajax selectbox',
        'class' => 'FacetapiAjaxWidgetSelect',
        'query types' => array('term'),
      ),
    ),
    'facetapi_ajax_links' => array(
      'handler' => array(
        'label' => 'Ajax links',
        'class' => 'FacetapiAjaxWidgetLinks',
        'query types' => array('term'),
      ),
    ),
    'facetapi_ajax_ranges' => array(
      'handler' => array(
        'label' => 'Ajax ranges',
        'class' => 'FacetapiAjaxWidgetRanges',
        'query types' => array('term'),
      ),
    ),
  );
}


/**
 * Implements hook_facetapi_empty_behaviors().
 */
function ajax_facets_facetapi_empty_behaviors() {
  return array(
    'ajax_facets' => array(
      'handler' => array(
        'label' => t('Display ajax_facets wrapper'),
        'class' => 'FacetapiEmptyBehaviorAjaxFacets',
      ),
    ),
  );
}

/**
 * Add required JS and handle single inclusion.
 */
function ajax_facets_add_ajax_js($facet) {
  static $included = FALSE;
  if (!$included) {
    $included = TRUE;
    $history_js_exists = FALSE;
    $module_path = drupal_get_path('module', 'ajax_facets');
    drupal_add_js($module_path . '/misc/ajax_facets.js');
    drupal_add_css($module_path . '/misc/ajax_facets.css');
    $search_path = $facet->getAdapter()->getSearchPath();
    $filter_key = $facet->getAdapter()->getUrlProcessor()->getFilterKey();
    // Note that we add in query only filter params and exclude pages and etc...
    $query = (isset($_GET[$filter_key])) ? array($filter_key => $_GET[$filter_key]) : array();
    $current_views = search_api_current_search();
    $processable_views = [];

    // Add history.js file if exists.
    if (module_exists('libraries')) {
      $history_js_path = libraries_get_path('history.js');

      if ($history_js_path) {
        $history_js_exists = TRUE;
        drupal_add_js($history_js_path . '/scripts/bundled/html4+html5/jquery.history.js', array('group' => JS_LIBRARY));
      }
    }

    if (!empty($current_views)) {
      // Get displays from current search.
      $keys = array_keys($current_views);
      foreach ($keys as $key) {
        if (substr_count($key, 'search_api_views')) {
          $parts = explode(':', $key);
          $processable_views[] = array(
            'view_name' => $parts[1],
            'view_display_id' => $parts[2]
          );
        }
      }
    }

    $facet = $facet->getFacet();
    $setting['facetapi'] = array(
      'defaultQuery' => isset($_GET[$filter_key]) ? $_GET[$filter_key] : '',
      'searchUrl' => url($search_path),
      'index_id' => $facet['map options']['index id'],
      'views' => $processable_views,
      'facet_field' => $facet['map options']['field']['key'],
      'applyPath' => url($search_path, array('query' => $query)),
      'isHistoryJsExists' => $history_js_exists,
    );
    drupal_add_js($setting, 'setting');
    drupal_add_library('system', 'drupal.ajax');
  }
}

/**
 * Return Drupal formed url for reset current facet filter.
 */
function ajax_facets_facet_build_reset_path($facet, $adapter) {
  $params = $adapter->getUrlProcessor()->fetchParams();
  $filter_key = $adapter->getUrlProcessor()->getFilterKey();
  $clean_params = array();
  $url_params = array();

  // Build query params except current facet filters.
  if (!empty($params[$filter_key])) {
    foreach ($params[$filter_key] as $param) {
      if (strpos($param, $facet['name']) !== 0) {
        $clean_params[] = $param;
      }
    }
    $url_params = array();
    if (!empty($clean_params)) {
      $url_params = array('query' => array($filter_key => $clean_params));
    }

    $unset_keys = array('searchPath', 'q', 'page', $filter_key);
    // Remove default params from redirect.
    foreach ($params as $key => $value) {
      if (!in_array($key, $unset_keys)) {
        $url_params['query'][$key] = $value;
      }
    }
  }
  return url((!empty($_GET['searchPath']) ? $_GET['searchPath'] : $adapter->getSearchPath()), $url_params);
}

/**
 * Return Drupal formed url for apply current facets state.
 */
function ajax_facets_facet_build_apply_path($adapter) {
  $params = $adapter->getUrlProcessor()->fetchParams();
  $unset_keys = array('searchPath', 'q', 'page');
  // Remove default params from redirect.
  foreach ($unset_keys as $key) {
    if (isset($params[$key])) {
      unset($params[$key]);
    }
  }
  // Remove empty filter key.
  $filter_key = $adapter->getUrlProcessor()->getFilterKey();
  if (isset($params[$filter_key]) && empty($params[$filter_key])) {
    unset($params[$filter_key]);
  }
  $url_params = !empty($params) ? array('query' => $params) : array();
  return url((!empty($_GET['searchPath']) ? $_GET['searchPath'] : $adapter->getSearchPath()), $url_params);
}

/**
 * Implementation of hook_views_ajax_data_alter()
 */
function ajax_facets_views_ajax_data_alter(&$commands, $view) {
  // As long as we're on a search api index view
  if (strpos($view->base_table, 'search_api_index') !== FALSE) {
    // We can get the index ID from the view base table
    $index_id = str_replace('search_api_index_', '', $view->base_table);
    // Create the searcher name
    $searcher = 'search_api@' . $index_id;
    // Get our facet blocks
    $blocks = ajax_facets_process_facet_blocks($searcher);
    // Create commands to replace each block. We should use ID's because all facets have it.
    foreach ($blocks['facet_blocks'] as $id => $content) {
      $commands[] = ajax_command_replace("#$id-wrapper", $content);
    }
    // Show all blocks
    $commands[] = ajax_command_invoke('div.block-facetapi:not(:visible)', 'show');
    // Hide empty blocks
    foreach ($blocks['hide_blocks'] as $block_id) {
      $commands[] = ajax_command_invoke("#$block_id", 'hide');
    }
    // Update the views ajax path with the facet query so that exposed filter
    // page requests knows which facets are enabled
    $facet_query = !empty($_GET['f']) ? $_GET['f'] : '';
    if ($facet_query) {
      $settings = array(
        'views' => array(
          'ajax_path' => url('views/ajax', array('query' => array('f' => $facet_query))),
        ),
      );
      // We need to put this at the head of the commands so that it runs before
      // the views commands. This is because ajax_render() in ajax.inc prepends
      // it's own settings command to the commands array which will change
      // views ajax_path back to views/ajax. If we don't fix this before views
      // runs it's ajax commands, the views ajax event won't get the facets in
      // the path and they'll be reset on exposed filter input.
      array_unshift($commands, ajax_command_settings($settings, TRUE));
    }
  }
}

/**
 * Generates an array of facet block data for a given searcher and realm
 *
 * @param  string $searcher
 *         The machine name of the searcher.
 *
 * @param  string $realm_name
 *         The machine name of the realm
 *
 * @return array
 *         An array of facet block data
 */
function ajax_facets_process_facet_blocks($searcher, $realm_name = 'block') {

  $map = facetapi_get_delta_map();
  $facets_to_proceed = array();
  $enabled_facets = facetapi_get_enabled_facets($searcher, $realm_name);
  foreach ($enabled_facets as $facet) {
    $facets_to_proceed[] = $facet['name'];
  }

  // Our return array
  $blocks = array(
    'facet_blocks' => array(),
    'hide_blocks' => array(),
    'reset_urls' => array(),
    'active_items' => array(),
  );

  $group = $searcher . ':' . $realm_name;
  $realm = facetapi_realm_load($realm_name);
  // Process values once per searcher-realm group.
  $adapter = facetapi_adapter_load($searcher);
  $builds[$group] = facetapi_build_realm($searcher, $realm_name);
  // Take search id.
  $search_id = key(search_api_current_search());

  // Process facets.
  foreach ($facets_to_proceed as $facet_name) {
    $facet = $adapter->getFacet(array('name' => $facet_name));
    //$facet->getSettings($builds[$group])->settings['facet_search_ids']
    //search_api_views:search_results:page
    // First check if the facet is enabled for this search.
    $settings = $facet->getSettings()->settings;

    $default_true = isset($settings['default_true']) ? $settings['default_true'] : TRUE;
    $facet_search_ids = isset($settings['facet_search_ids']) ? $settings['facet_search_ids'] : array();
    // If facet is enabled for this search id.
    // TODO replace it on facetapi_check_block_visibility() ?
    if ($default_true == empty($facet_search_ids[$search_id])) {
      $blocks['reset_urls'][$facet_name] = ajax_facets_facet_build_reset_path($facet, $adapter);
      if (!empty($builds[$group][$facet_name]) && $build = $facet->getBuild()) {
        $blocks['active_items'][$facet_name] = array();
        foreach ($build as $key => $value) {
          if (!empty($value['#active'])) {
            $blocks['active_items'][$facet_name][] = "$facet_name:$key";
          }
        }
        if (!empty($blocks['active_items'][$facet_name])) {
          sort($blocks['active_items'][$facet_name]);
        }

        // Skip currently checked facet - we will not refresh them.
        $blocks['facet_blocks'][$builds[$group][$facet_name]['#attributes']['id']] = drupal_render($builds[$group][$facet_name]);
      }
      else {
        $facet_name = rawurlencode($facet_name);
        $delta = array_search("$searcher:$realm_name:$facet_name", $map);
        $blocks['hide_blocks'][] = 'block-facetapi-' . strtolower($delta);
      }

      // Settings for update view.
      $facet_settings = $facet->getSettings($realm);
      $update_results = !empty($facet_settings->settings['update_results']) ? $facet_settings->settings['update_results'] : 0;
      $blocks['update_results'][$facet_name] = $update_results;
    }
  }

  return $blocks;
}

/**
 * Implements hook_form_form_id_alter().
 */
function ajax_facets_form_facetapi_facet_display_form_alter(&$form, $form_state) {
  // Add JS file for settings form of each facet.
  drupal_add_js(drupal_get_path('module', 'ajax_facets') . '/misc/ajax_facets.admin.js');
}

/**
 * Implements hook_views_pre_render().
 */
function ajax_facets_views_pre_render(&$view) {
  // We use static because we should collect data from all the views.
  static $setting;

  // Save settings of rendered views, to use them in request for AJAX facets.
  $name_display = $base = "$view->name:$view->current_display";
  $i = 0;
  // Use unique key as in search_api_current_search().
  while (isset($setting['facetapi']['view_args'][$name_display])) {
    $name_display = $base . '-' . ++$i;
  }
  $setting['facetapi']['view_args'][$name_display] = $view->args;
  $setting['facetapi']['exposed_input'][$name_display] = $view->exposed_raw_input;
  $setting['facetapi']['view_path'][$name_display] = $view->get_path();
  $setting['facetapi']['view_dom_id'][$name_display] = $view->dom_id;

  drupal_add_js($setting, 'setting');
}

/**
 * Implements hook_i18n_string_info().
 */
function ajax_facets_i18n_string_info() {
  $groups['ajax_facets'] = array(
    'title' => t('Ajax facets'),
    'description' => t('Translatable ajax facets: label.'),
    // This group doesn't have strings with format.
    'format' => FALSE,
    // This group can list all strings.
    'list' => TRUE,
  );
  return $groups;
}

/**
 * Submit handlers for settings form of facet filters.
 */
function ajax_facets_facet_settings_form_submit($form, $form_state) {
  $values = $form_state['values'];
  // Update the i18n strings if need.
  if (function_exists('i18n_string_update')) {
    if (!empty($values['widget'])) {
      if ($values['widget'] == 'facetapi_ajax_select') {
        // Label for the default option of ajax facets select widget..
        $name = array(
          'ajax_facets',
          'facet_label',
          str_replace(':', '_', $form['#facetapi']['facet']['name']),
          'label'
        );
        i18n_string_update($name, $values['ajax_select_default_option_label']);
      }

      // Reset link text.
      if ($values['show_reset_link'] && !empty($values['reset_link_text'])) {
        // Text for the reset link.
        $reset_link_text = array(
          'ajax_facets',
          'reset_link_text',
          str_replace(':', '_', $form['#facetapi']['facet']['name']),
          'value'
        );
        i18n_string_update($reset_link_text, $values['reset_link_text']);
      }
    }
  }
}
